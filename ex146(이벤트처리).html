<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이벤트처리하기 예제</title>
    <script>
        const inputContainer = document.getElementById("input-container")
        console.log(inputContainer) // NULL => JS가 DOM을 생성하기도 전에 먼저 실행되었음.
        /*
        addEventListener의 첫번째 매개변수는 이벤트 타입, 두번째는 콜백함수
        이벤트 객체에는 target, type과 같은 속성과 preventDefault, stopPropagation과 같은 메소드들이 있습니다

        */

        /*
        DOM이 로드된 후에 선언을 해주기 때문에 null이 나오지 않음
        즉 DOM트리가 완성되면 호출됨. 이미지나 스타일 시트와 같은 외부리소스는 로드되지 않은 상태!!
        외부 리소스 까지 로드된 이벤트를 처리한다면 onload 이벤트타입을 사용
        onload 이벤트는 window.onload에 함수를 할당하는 방식으로 사용

        */
        document.addEventListener('DOMContentLoaded',e => {
            const inputContainer = document.getElementById('input-container')
            console.log(inputContainer) 
            /*
            <div id="input-container">
            <input type="text">
            <button>버튼</button>
            </div>
            */

            const inputEl = inputContainer.querySelector('input')
            inputEl.addEventListener('keydown', e => {
                console.log(`keyCode : ${e.keyCode}`) // 이벤트 객체의 키코드 속성을 통해 어떠한 키가 눌렸는지 확인할 수 있음
            })

            const buttonEl = inputContainer.querySelector('button')
            buttonEl.addEventListener('click', e=>{
                // console.log(this) 화살표 함수에서 this는 window 객체를 가리킴.
                // 만약 화살표 함수가 아니라 일반함수를 사용했다면 this는 이 target을 가리킴 
                console.log(e.target) // <button>버튼</button>
                console.log(`input value: ${inputEl.value}`)

            })

            
           
        })

    </script>
</head>
<body>
    <div id="input-container">
        <input type="text">
        <button>버튼</button>
    </div>
</body>
</html>